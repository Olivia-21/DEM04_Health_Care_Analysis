Decision 1: Fact Table Grain 

Option A - One row per encounter

Justification:

This grain best supports all four business questions: 
Monthly encounters by specialty 
Encounter is the natural atomic event. 
2. Top diagnosis-procedure pairs
Use bridge tables to associate diagnoses and procedures to encounters. 
3. 30-day readmission pairs
Readmissions are defined at the encounter level
4. Revenue by specialty and month
Billing is tied to encounters

Choosing a finer grain (diagnosis-level or procedure-level) would unnecessarily multiply rows, increase storage and complicate aggregation without improving performance for these queries. 


Decision 2: Dimension Tables

Dimension Date (dim_date)
date_key (INT, PK) - Surrogate key in YYYYMMDD format
calendar_date (DATE) - Actual date
year (INT)
quarter (INT) - 1, 2, 3, 4
month (INT) - 1-12
month_name (VARCHAR) - "January", "February", etc.
day_of_month (INT) - 1-31
day_of_week (INT) - 1-7
day_name (VARCHAR) - "Monday", "Tuesday", etc.
week_of_year (INT) - 1-53


Dimension patient (dim_patient)
patient_key (PK)
patient_id (business key)
first_name
last_name
gender
date_of_birth
age 
age_group
mrn

Dimension provider(dim_provider)
provider_key 
provider_id
first_name 
last_name 
full_name 
credential
specialty_id 
specialty_name
specialty_code
department_id
department_name 
dim_specialty
specialty_key 
specialty_id
specialty_name
specialty_code

Dimension specialty (dim_specialty)
specialty_key
specialty_id
specialty_name
specialty_code


Dimension Depatment (dim_department)
department_key
depeartment_id
department_name
floor
capacity

Dimension Encounter Type (dim_encounter_type)
encounter_type_key 
encounter_type_name

Dimension Procedure (dim_procedure)
procedure_key
procedure_id
cpt_code
cpt_description

Dimension diagnosis (dim_diagnosis)
diagnosis_key
diagnosis_id
icd10_code
icd10_description


 
Decision 3: Pre-Aggregated Metrics

Metrics stored in fact_encounters
diagnosis_count
procedure_count
total_claim_amount
total_allowed_amount
billing_count
length_of_stay_days
is_readmission
days_since_last_discharge 

Why Pre-Aggregation Helps Performance
Avoids expensive joins to diagnoses, procedure, and billing tables
Reduces row scanning and aggregation cost
Enables fast GROUP BY queries on fact table only
Shifts computation from query time to ETL time

Decision 4: Bridge Tables
Decision : 
Yes, I will use bridge tables

Justification: 
Diagnoses and procedures are many-to-many
Storing them directly in the fact table would cause row explosion
Bridge tables preserve flexibility for detailed analysis without bloating the fact table


Decision 5: Denormalized Attributes in Fact Table

Decision:
Denormalize frequently-queried dimension attributes directly into fact_encounters:
- specialty_name (from dim_provider/dim_specialty)
- encounter_type_name (from dim_encounter_type)
- encounter_year, encounter_month, encounter_month_name (from dim_date)

Justification:
1. Eliminates JOINs for the most common analytical queries (Q1, Q3, Q4)
2. These attributes are small (VARCHAR/INT) and add minimal storage overhead
3. These attributes rarely change (specialty names, encounter types are stable)
4. Follows star schema best practice: trade storage redundancy for query performance

Impact on Query Performance:
| Query | JOINs Before | JOINs After | Improvement |
|-------|--------------|-------------|-------------|
| Q1    | 3            | 0           | 1.5x faster |
| Q3    | 1            | 0           | 3.4x faster |
| Q4    | 2            | 0           | 1.9x faster |

Trade-off:
- Slightly increased storage (estimated 5-10% increase in fact table size)
- ETL must populate these denormalized columns during load
- If specialty/encounter_type changes, historical facts retain old values (acceptable for analytics)




