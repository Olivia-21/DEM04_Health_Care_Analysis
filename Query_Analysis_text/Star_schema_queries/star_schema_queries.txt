QUESTION 1: Monthly Encounters by Specialty
SQL QUERY:

EXPLAIN ANALYZE
SELECT 
    d.year,
    d.month,
    d.month_name,
    p.specialty_name,
    et.encounter_type_name,
    COUNT(f.encounter_key) AS total_encounters,
    COUNT(DISTINCT f.patient_key) AS unique_patients
FROM fact_encounters f
JOIN dim_date d ON f.encounter_date_key = d.date_key
JOIN dim_provider p ON f.provider_key = p.provider_key
JOIN dim_encounter_type et ON f.encounter_type_key = et.encounter_type_key
GROUP BY 
    d.year,
    d.month,
    d.month_name,
    p.specialty_name,
    et.encounter_type_name
ORDER BY d.year, d.month, p.specialty_name, et.encounter_type_name;


Execution Time Estimate: 53.1ms vs 51.5ms
Improvement factor: 1x faster
Explanation
Ans: Star schema is about the same as OLTP because the query still aggregates over a large fact table and both need similar joins. There is no huge advantage since the data is not big enough to benefit from denormalization.






QUESTION 2: Diagnosis-Procedure Pairs
SQL QUERY:
EXPLAIN ANALYZE
SELECT 
    d.icd10_code,
    d.icd10_description,
    pr.cpt_code,
    pr.cpt_description,
    COUNT(DISTINCT bd.encounter_key) AS encounter_count
FROM bridge_encounter_diagnoses bd
JOIN dim_diagnosis d ON bd.diagnosis_key = d.diagnosis_key
JOIN bridge_encounter_procedures bp ON bd.encounter_key = bp.encounter_key
JOIN dim_procedure pr ON bp.procedure_key = pr.procedure_key
GROUP BY 
    d.icd10_code,
    d.icd10_description,
    pr.cpt_code,
    pr.cpt_description
ORDER BY encounter_count DESC
LIMIT 20;

Execution Time Estimate: 226ms vs 309ms
Improvement factor: 1.4x faster
Explanation
Ans: Star schema is much faster because it uses pre-keyed bridge tables and fewer joins, avoiding multiple heavy table lookups that OLTP has, though both still experience some row multiplication.






QUESTION 3: Readmission Rate
SQL QUERY:

EXPLAIN ANALYZE
SELECT 
    p.specialty_name,
    COUNT(f.encounter_key) AS total_inpatient_discharges,
    SUM(f.is_readmission) AS readmission_count,
    ROUND(SUM(f.is_readmission) * 100.0 / COUNT(f.encounter_key), 2) AS readmission_rate_pct
FROM fact_encounters f
JOIN dim_provider p ON f.provider_key = p.provider_key
WHERE f.is_inpatient = TRUE
  AND f.discharge_date IS NOT NULL
GROUP BY p.specialty_name
ORDER BY readmission_rate_pct DESC;

Execution Time Estimate: 14.9ms vs 51.1ms
Improvement factor:0.19
Explanation
Ans: Star schema is slower here because of the self-join on the large fact table, which creates many row comparisons. OLTP is faster because it likely scans fewer rows or has smaller join sets for this query.






QUESTION 4: Revenue by Specialty and Month
SQL QUERY:

EXPLAIN ANALYZE
SELECT 
    d.year,
    d.month,
    d.month_name,
    p.specialty_name,
    COUNT(f.encounter_key) AS encounter_count,
    SUM(f.total_allowed_amount) AS total_revenue,
    AVG(f.total_allowed_amount) AS avg_revenue_per_encounter
FROM fact_encounters f
JOIN dim_date d ON f.encounter_date_key = d.date_key
JOIN dim_provider p ON f.provider_key = p.provider_key
GROUP BY 
    d.year,
    d.month,
    d.month_name,
    p.specialty_name
ORDER BY d.year, d.month, total_revenue DESC;

Execution Time Estimate: 79.8ms vs 85.5ms
Improvement factor: 1.07x faster
Explanation
Ans: Star schema is faster because the fact table already stores total allowed amounts and keys to small dimensions, so aggregation is quicker, whereas OLTP needs multiple joins and calculations like DATE_FORMAT





