QUESTION 1- Monthly Encounters by Specialty
SQL QUERY:

EXPLAIN ANALYZE
SELECT
    DATE_FORMAT(e.encounter_date, '%Y-%m') AS encounter_month,
    s.specialty_name,
    e.encounter_type,
    COUNT(*) AS total_encounters,
    COUNT(DISTINCT e.patient_id) AS unique_patients
FROM encounters e
JOIN providers p ON e.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
GROUP BY
    DATE_FORMAT(e.encounter_date, '%Y-%m'),
    s.specialty_name,
    e.encounter_type
ORDER BY encounter_month, specialty_name;

SCHEMA ANALYSIS:
Tables joined: encounters, providers and specialties.
Number of joins: 2
Performance:
Execution time: 81.6ms
Sorted rows: 10,000
Rows Examined: 21020 rows
Bottleneck Identified: Expensive GROUP BY with sorting and COUNT (DISTINCT) after processing a large intermediate result set. 
Why is this slow?
Ans: The query is slow because MySQL must process and sort 10,000 intermediate rows created by joins before performing a GROUP BY aggregation that includes a COUNT (DISTINCT patient_id), which requires additional deduplication. 

What's the root cause?
Ans: The root cause is the normalized OLTP schema, which requires multiple joins to retrieve specialty information and perform aggregation at query runtime. 








QUESTION 2: Top Diagnosis-procedure pairs
SQL QUERY:

EXPLAIN ANALYZE
SELECT
    d.icd10_code,
    pr.cpt_code,
    COUNT(*) AS encounter_count
FROM encounter_diagnoses ed
JOIN diagnoses d ON ed.diagnosis_id = d.diagnosis_id
JOIN encounter_procedures ep ON ed.encounter_id = ep.encounter_id
JOIN procedures pr ON ep.procedure_id = pr.procedure_id
GROUP BY d.icd10_code, pr.cpt_code
ORDER BY encounter_count DESC;

SCHEMA ANALYSIS:
Tables joined: encounter_diagnoses, diagnoses, encounter_procedures and procedures
Number of joins: 3
Performance:
Execution time: 268.30ms
Sorted rows: 36686 rows
Rows Examined:137038 rows
Bottleneck Identified:

Why is this slow?
Ans: The query is slow because MySQL must first create a temporary table to store grouped results and then perform a full scan and sort on that temporary table. 

What's the root cause?
Ans: The root cause is running analytics-style queries(GROUP BY, ORDER BY) on a normalized OLTP schema. OLTP tables are optimized for transaction which forces the database to create temporary tables and perform expensive scans and sorts. 







QUESTION 3: 30-Day Readmission Rate
SQL QUERY:

EXPLAIN ANALYZE
SELECT
    DATE_FORMAT(e.encounter_date, '%Y-%m') AS encounter_month,
    s.specialty_name,
    e.encounter_type,
    COUNT(*) AS total_encounters,
    COUNT(DISTINCT e.patient_id) AS unique_patients
FROM encounters e
JOIN providers p ON e.provider_id = p.provider_id
JOIN specialties s ON p.specialty_id = s.specialty_id
GROUP BY
    DATE_FORMAT(e.encounter_date, '%Y-%m'),
    s.specialty_name,
    e.encounter_type
ORDER BY encounter_month, specialty_name;

SCHEMA ANALYSIS:
Tables joined: encounters(twice, self join), providers and specialties.
Number of joins: 3
Performance:
Execution time: 29.83ms
Sorted rows: 89
Rows examined: 13762 rows
Bottleneck Identified:

Why is this slow?
Ans: The query uses a self-join on the encounters table to detect readmissions, This requires comparing each inpatient encounter with subsequent encounters for the same patient within a date range, with increases processing complexity. 

What's the root cause?
Ans: The root cause is the need to perform a self-join on a transactional table to derive readmission logic. The database must repeatedly scan and compare encounter records per patient. 







QUESTION 4: Revenue by Specialty and Month
SQL QUERY:

EXPLAIN ANALYZE
SELECT
    d.icd10_code,
    pr.cpt_code,
    COUNT(*) AS encounter_count
FROM encounter_diagnoses ed
JOIN diagnoses d ON ed.diagnosis_id = d.diagnosis_id
JOIN encounter_procedures ep ON ed.encounter_id = ep.encounter_id
JOIN procedures pr ON ep.procedure_id = pr.procedure_id
GROUP BY d.icd10_code, pr.cpt_code
ORDER BY encounter_count DESC;

SCHEMA ANALYSIS:
Tables joined: billing, encounters, providers and specialties
Number of joins: 3
Performance:
Execution time: 52.47ms
Sorted rows: 500
Rows Examined: 40500
Bottleneck Identified:
Why is this slow?
Ans: Because there is a multiple table join before performing aggregation. After the joins, MySQL calculates total revenue and groups the data by month and specialty, which requires additional processing and sorting. 

What's the root cause?
Ans: There is a long join chain combined with aggregation on a normalized OLTP schema. Revenue data is stored separately from the descriptive attributes like specialty, so the database must join several tables and process more rows than necessary. 



















